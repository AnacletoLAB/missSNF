% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/missSNF.R
\name{miss.snf}
\alias{miss.snf}
\title{miss-SNF: integration of patients' networks considering missing cases}
\usage{
miss.snf(
  Mall,
  sims,
  sims.arg = vector("list", length(sims)),
  mode = "reconstruct",
  perc.na = 0.2,
  miss.symbols = NULL,
  K = 20,
  t = 20,
  impute = "median",
  d = 1,
  random.walk = "none",
  p = 3,
  seed = NULL
)
}
\arguments{
\item{Mall}{list of named matrices/dataframes (samples x features).}

\item{sims}{vector of strings. It is a vector containing the names of the
similarity measures to apply to the matrices in Mall.
"scaled.exp.euclidean" is the scaled exponential euclidean distance;
"scaled.exp.chi2" is the scaled exponential chi-square distance}

\item{sims.arg}{list. List with the same length of "sims" where each elements
is a list containing additional arguments for each
similarity measure in the argument "sims". Set element to
NULL if you want to use default parameters for a specific
similarity measure (default).}

\item{mode}{string. If you want to partially reconstruct missing data use
"reconstruct" or "one" (default), otherwise ignore them during integration
using "ignore" or "zero". If you use "equidistant", the self-loop
for partial samples is set to 0.5 while the similarity with other
samples is set to the same value so that the sample is equidistant
from all other samples but more similar to itself than others.
The option "random" sets randomly the similarity of partial
samples (let's consider this as a baseline).}

\item{perc.na}{percentage of NAs above which a patient is considered missing.}

\item{miss.symbols}{vector of strings. If not NULL, the provided symbols
in matrices are converted to NA.}

\item{K}{Number of neighbors in K-nearest neighbors part of the algorithm.}

\item{t}{Number of iterations for the diffusion process.}

\item{impute}{string. Kind of imputation method to apply in case of samples
with few missing values. Options are: NULL, "mean", "median".
NOTE: if impute=NULL, then perc.na has to be 0 (i.e.
having even one NA will make the patient treated as missing).}

\item{d}{numeric. Set the diagonal of the matrix to "d" if
mode="reconstruct" or mode="one" (def d=1).}

\item{random.walk}{string. Use 1-step Random Walk to compute the local
similarity matrix S and/or p-step Random Walk (p>=2) to compute the global
similarity matrix P. random.walk=c("global", "local", "both", "none") and
defaults is random.walk="none".}

\item{p}{numeric. Number of steps for the p-step RW. Used only when
global similarity matrix is computed through p-step Random Walk.}

\item{seed}{numeric. Seed to get reproducible results. Needed only if
mode = "random".}
}
\value{
A list with two elements:
\itemize{
\item W : integrated similarity matrix. Note that the order of the patients
is different from the order of the original matrices.
\item removed.pts : vector with names of removed patients (i.e. patients
present only in one matrix of Mall and having too much NAs or, more in general,
if a patient is considered missing in all data sources).
\item conv1 : vector with the Frobenius norm between the standard deviation across
global matrices after cross-diffusion, considering consecutive steps.
\item conv2 : vector containing the Frobenius norm of the difference among the
integrated matrices at two consecutive steps.
 \item conv3 : vector containing the Frobenius norm of the difference among the
integrated matrix at each iteration and the final integrated matrix (measures
convergence velocity).
}
}
\description{
Extension of the algorithm Similarity Network Fusion
(\url{https://doi.org/10.1038/nmeth.2810}) able to handle the absence (complete or
nearly complete) of a specific data source for a given patient by:
\loadmathjax
\itemize{
\item "reconstruct strategy" that can partially reconstruct missing
  data by using information from different sources (i.e. miss-SNF ONE).
\item "ignore strategy" which simply ignores missing data during the integration
  process (i.e. miss-SNF ZERO).
\item "equidistant strategy", similar to reconstruct but sets the similarity
of the partial samples with the others to a fixed value instead of zero.
\item "random strategy" that sets the similatiry randomly.
}
}
\examples{

# Create list of input matrices
set.seed(123);
M1 <- matrix(runif(50, min = 0, max = 1), nrow = 5); # 5 samples
rownames(M1) <- paste0("ID_", 1:nrow(M1));
M1[1, 1:4] <- c(NA, NA, NA, NA);
M1[4, ] <- rep(NA, ncol(M1));

M2 <- matrix(runif(80, min = 0, max = 1), nrow = 8); # 8 samples
rownames(M2) <- paste0("ID_", 3:10);
M2[2, ] <- rep(NA, ncol(M2));
M2[4, ] <- rep(NA, ncol(M2));
M2[8, 1] <- NA;

M3 <- matrix(runif(80, min = 0, max = 1), nrow = 8); # 8 samples
rownames(M3) <- c(paste0("ID_", 1:5), paste0("ID_", 11:13));
M3[4, 1] <- NA;
M3[7, ] <- rep(NA, ncol(M3));

Mall <- list("M1"=M1, "M2"=M2, "M3"=M3);

# Call miss.snf using "reconstruct strategy"
W.r <- miss.snf(Mall, sims=rep("scaled.exp.euclidean", 3),
               sims.arg=list(list(kk=2), list(kk=2), list(kk=2)),
               mode="reconstruct", K=3);

# Call miss.snf using "ignore strategy"
W.i <- miss.snf(Mall, sims=rep("scaled.exp.euclidean", 3),
               sims.arg=list(list(kk=2), list(kk=2), list(kk=2)),
               mode="ignore", K=3);
}
